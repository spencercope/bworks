/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.0.0 (NJsonSchema v9.12.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class UserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.81.219.113:3000/api";
    }

    /**
     * Login
     */
    login(loginParams: LoginParams): Observable<LoginResponseVm> {
        let url_ = this.baseUrl + "/users/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<LoginResponseVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginResponseVm>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponseVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? LoginResponseVm.fromJS(resultData201) : new LoginResponseVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponseVm>(<any>null);
    }

    /**
     * Register
     */
    register(loginParams: LoginParams): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<UserVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserVm>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<UserVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? UserVm.fromJS(resultData201) : new UserVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserVm>(<any>null);
    }

    /**
     * GetAllUsers
     */
    getAllUsers(): Observable<UserVm[]> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<UserVm[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserVm.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserVm[]>(<any>null);
    }

    /**
     * Me
     */
    me(): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMe(<any>response_);
                } catch (e) {
                    return <Observable<UserVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserVm>><any>_observableThrow(response_);
        }));
    }

    protected processMe(response: HttpResponseBase): Observable<UserVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserVm.fromJS(resultData200) : new UserVm();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserVm>(<any>null);
    }

    /**
     * CreateUser
     */
    createUser(createUserParams: CreateUserParams): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/create-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createUserParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(<any>response_);
                } catch (e) {
                    return <Observable<UserVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserVm>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<UserVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? UserVm.fromJS(resultData201) : new UserVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserVm>(<any>null);
    }

    /**
     * ChangePassword
     */
    changePassword(changePasswordParams: ChangePasswordParams, id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/users/change-password/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changePasswordParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * ChangePasswordByAdmin
     */
    changePasswordByAdmin(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/users/change-password-admin/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePasswordByAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePasswordByAdmin(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePasswordByAdmin(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * UpdateUser
     */
    updateUser(userVm: UserVm): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userVm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<UserVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserVm>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<UserVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? UserVm.fromJS(resultData201) : new UserVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserVm>(<any>null);
    }

    /**
     * DeleteUser
     */
    deleteUser(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/users/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class FileReferenceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.81.219.113:3000/api";
    }

    /**
     * UpdateProfilePic
     * @param image (optional) Image
     */
    updateProfilePic(itemId: string, image?: FileParameter | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/file-references/image?";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined and cannot be null.");
        else
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (image !== null && image !== undefined)
            content_.append("image", image.data, image.fileName ? image.fileName : "image");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePic(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePic(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ItemClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.81.219.113:3000/api";
    }

    /**
     * CreateBaseItem
     * @param isOffsite (optional) 
     * @param barcodeId (optional) 
     */
    createBaseItem(itemVm: ItemVm, donorId: string, isOffsite?: boolean | null | undefined, barcodeId?: string | null | undefined): Observable<ItemVm> {
        let url_ = this.baseUrl + "/items?";
        if (donorId === undefined || donorId === null)
            throw new Error("The parameter 'donorId' must be defined and cannot be null.");
        else
            url_ += "donorId=" + encodeURIComponent("" + donorId) + "&"; 
        if (isOffsite !== undefined)
            url_ += "isOffsite=" + encodeURIComponent("" + isOffsite) + "&"; 
        if (barcodeId !== undefined)
            url_ += "barcodeId=" + encodeURIComponent("" + barcodeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(itemVm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBaseItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBaseItem(<any>response_);
                } catch (e) {
                    return <Observable<ItemVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemVm>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBaseItem(response: HttpResponseBase): Observable<ItemVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? ItemVm.fromJS(resultData201) : new ItemVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemVm>(<any>null);
    }

    /**
     * GetAllItems
     */
    getAllItems(): Observable<ItemVm[]> {
        let url_ = this.baseUrl + "/items";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllItems(<any>response_);
                } catch (e) {
                    return <Observable<ItemVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllItems(response: HttpResponseBase): Observable<ItemVm[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ItemVm.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemVm[]>(<any>null);
    }

    /**
     * UpdateBikeItem
     */
    updateBikeItem(bikeVm: BikeVm, id: string): Observable<BikeVm> {
        let url_ = this.baseUrl + "/items/bike/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bikeVm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBikeItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBikeItem(<any>response_);
                } catch (e) {
                    return <Observable<BikeVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<BikeVm>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBikeItem(response: HttpResponseBase): Observable<BikeVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? BikeVm.fromJS(resultData201) : new BikeVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BikeVm>(<any>null);
    }

    /**
     * UpdatePcItem
     */
    updatePcItem(pCVm: PCVm, id: string): Observable<PCVm> {
        let url_ = this.baseUrl + "/items/pc/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pCVm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePcItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePcItem(<any>response_);
                } catch (e) {
                    return <Observable<PCVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<PCVm>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePcItem(response: HttpResponseBase): Observable<PCVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? PCVm.fromJS(resultData201) : new PCVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PCVm>(<any>null);
    }

    /**
     * UpdatePartItem
     */
    updatePartItem(partVm: PartVm, id: string): Observable<PartVm> {
        let url_ = this.baseUrl + "/items/part/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(partVm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePartItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePartItem(<any>response_);
                } catch (e) {
                    return <Observable<PartVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<PartVm>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePartItem(response: HttpResponseBase): Observable<PartVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? PartVm.fromJS(resultData201) : new PartVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PartVm>(<any>null);
    }

    /**
     * UpdateMiscItem
     */
    updateMiscItem(miscVm: MiscVm, id: string): Observable<MiscVm> {
        let url_ = this.baseUrl + "/items/misc/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(miscVm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMiscItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMiscItem(<any>response_);
                } catch (e) {
                    return <Observable<MiscVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<MiscVm>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMiscItem(response: HttpResponseBase): Observable<MiscVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? MiscVm.fromJS(resultData201) : new MiscVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MiscVm>(<any>null);
    }

    /**
     * GetAllBikes
     */
    getAllBikes(): Observable<BikeVm[]> {
        let url_ = this.baseUrl + "/items/bikes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBikes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBikes(<any>response_);
                } catch (e) {
                    return <Observable<BikeVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BikeVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBikes(response: HttpResponseBase): Observable<BikeVm[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BikeVm.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BikeVm[]>(<any>null);
    }

    /**
     * GetAllPCs
     */
    getAllPCs(): Observable<PCVm[]> {
        let url_ = this.baseUrl + "/items/pcs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPCs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPCs(<any>response_);
                } catch (e) {
                    return <Observable<PCVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PCVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPCs(response: HttpResponseBase): Observable<PCVm[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PCVm.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PCVm[]>(<any>null);
    }

    /**
     * GetAllParts
     */
    getAllParts(): Observable<PartVm[]> {
        let url_ = this.baseUrl + "/items/parts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllParts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllParts(<any>response_);
                } catch (e) {
                    return <Observable<PartVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PartVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllParts(response: HttpResponseBase): Observable<PartVm[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PartVm.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PartVm[]>(<any>null);
    }

    /**
     * GetAllMiscs
     */
    getAllMiscs(): Observable<MiscVm[]> {
        let url_ = this.baseUrl + "/items/miscs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMiscs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMiscs(<any>response_);
                } catch (e) {
                    return <Observable<MiscVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MiscVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMiscs(response: HttpResponseBase): Observable<MiscVm[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MiscVm.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MiscVm[]>(<any>null);
    }

    /**
     * GetBikeById
     */
    getBikeById(id: string): Observable<BikeVm> {
        let url_ = this.baseUrl + "/items/bikes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBikeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBikeById(<any>response_);
                } catch (e) {
                    return <Observable<BikeVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<BikeVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetBikeById(response: HttpResponseBase): Observable<BikeVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BikeVm.fromJS(resultData200) : new BikeVm();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BikeVm>(<any>null);
    }

    /**
     * GetPcById
     */
    getPcById(id: string): Observable<PCVm> {
        let url_ = this.baseUrl + "/items/pcs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPcById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPcById(<any>response_);
                } catch (e) {
                    return <Observable<PCVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<PCVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetPcById(response: HttpResponseBase): Observable<PCVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PCVm.fromJS(resultData200) : new PCVm();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PCVm>(<any>null);
    }

    /**
     * GetPartById
     */
    getPartById(id: string): Observable<PartVm> {
        let url_ = this.baseUrl + "/items/parts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartById(<any>response_);
                } catch (e) {
                    return <Observable<PartVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<PartVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartById(response: HttpResponseBase): Observable<PartVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PartVm.fromJS(resultData200) : new PartVm();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PartVm>(<any>null);
    }

    /**
     * GetMiscById
     */
    getMiscById(id: string): Observable<MiscVm> {
        let url_ = this.baseUrl + "/items/miscs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMiscById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMiscById(<any>response_);
                } catch (e) {
                    return <Observable<MiscVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<MiscVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetMiscById(response: HttpResponseBase): Observable<MiscVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MiscVm.fromJS(resultData200) : new MiscVm();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MiscVm>(<any>null);
    }

    /**
     * GetItemByBarcodeId
     */
    getItemByBarcodeId(barcodeId: string): Observable<ItemVm> {
        let url_ = this.baseUrl + "/items/{barcodeId}";
        if (barcodeId === undefined || barcodeId === null)
            throw new Error("The parameter 'barcodeId' must be defined.");
        url_ = url_.replace("{barcodeId}", encodeURIComponent("" + barcodeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItemByBarcodeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItemByBarcodeId(<any>response_);
                } catch (e) {
                    return <Observable<ItemVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetItemByBarcodeId(response: HttpResponseBase): Observable<ItemVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ItemVm.fromJS(resultData200) : new ItemVm();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemVm>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DonorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.81.219.113:3000/api";
    }

    /**
     * CreateDonor
     */
    createDonor(createDonorParams: CreateDonorParams): Observable<DonorVm> {
        let url_ = this.baseUrl + "/donors/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDonorParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDonor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDonor(<any>response_);
                } catch (e) {
                    return <Observable<DonorVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<DonorVm>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDonor(response: HttpResponseBase): Observable<DonorVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? DonorVm.fromJS(resultData201) : new DonorVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DonorVm>(<any>null);
    }

    /**
     * GetAllDonors
     */
    getAllDonors(): Observable<DonorVm[]> {
        let url_ = this.baseUrl + "/donors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDonors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDonors(<any>response_);
                } catch (e) {
                    return <Observable<DonorVm[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DonorVm[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDonors(response: HttpResponseBase): Observable<DonorVm[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DonorVm.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DonorVm[]>(<any>null);
    }

    /**
     * GetDonorById
     */
    getDonorById(id: string): Observable<DonorVm> {
        let url_ = this.baseUrl + "/donors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDonorById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDonorById(<any>response_);
                } catch (e) {
                    return <Observable<DonorVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<DonorVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetDonorById(response: HttpResponseBase): Observable<DonorVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DonorVm.fromJS(resultData200) : new DonorVm();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DonorVm>(<any>null);
    }

    /**
     * SearchDonor
     */
    searchDonor(email: string): Observable<DonorVm> {
        let url_ = this.baseUrl + "/donors/search?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchDonor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchDonor(<any>response_);
                } catch (e) {
                    return <Observable<DonorVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<DonorVm>><any>_observableThrow(response_);
        }));
    }

    protected processSearchDonor(response: HttpResponseBase): Observable<DonorVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DonorVm.fromJS(resultData200) : new DonorVm();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DonorVm>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class HistoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.81.219.113:3000/api";
    }

    /**
     * AddTodoToBike
     * @param transferred (optional) 
     */
    addTodoToBike(todoVm: TodoVm, bikeId: string, transferred?: boolean | null | undefined): Observable<TodoVm> {
        let url_ = this.baseUrl + "/histories/todo/bike?";
        if (bikeId === undefined || bikeId === null)
            throw new Error("The parameter 'bikeId' must be defined and cannot be null.");
        else
            url_ += "bikeId=" + encodeURIComponent("" + bikeId) + "&"; 
        if (transferred !== undefined)
            url_ += "transferred=" + encodeURIComponent("" + transferred) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(todoVm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTodoToBike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTodoToBike(<any>response_);
                } catch (e) {
                    return <Observable<TodoVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<TodoVm>><any>_observableThrow(response_);
        }));
    }

    protected processAddTodoToBike(response: HttpResponseBase): Observable<TodoVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? TodoVm.fromJS(resultData201) : new TodoVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TodoVm>(<any>null);
    }

    /**
     * AddStoryToBike
     */
    addStoryToBike(storyVm: StoryVm, bikeId: string): Observable<StoryVm> {
        let url_ = this.baseUrl + "/histories/story/bike?";
        if (bikeId === undefined || bikeId === null)
            throw new Error("The parameter 'bikeId' must be defined and cannot be null.");
        else
            url_ += "bikeId=" + encodeURIComponent("" + bikeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(storyVm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddStoryToBike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddStoryToBike(<any>response_);
                } catch (e) {
                    return <Observable<StoryVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoryVm>><any>_observableThrow(response_);
        }));
    }

    protected processAddStoryToBike(response: HttpResponseBase): Observable<StoryVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? StoryVm.fromJS(resultData201) : new StoryVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoryVm>(<any>null);
    }

    /**
     * AddTodoToPc
     * @param transferred (optional) 
     */
    addTodoToPc(todoVm: TodoVm, pcId: string, transferred?: boolean | null | undefined): Observable<TodoVm> {
        let url_ = this.baseUrl + "/histories/todo/pc?";
        if (pcId === undefined || pcId === null)
            throw new Error("The parameter 'pcId' must be defined and cannot be null.");
        else
            url_ += "pcId=" + encodeURIComponent("" + pcId) + "&"; 
        if (transferred !== undefined)
            url_ += "transferred=" + encodeURIComponent("" + transferred) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(todoVm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTodoToPc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTodoToPc(<any>response_);
                } catch (e) {
                    return <Observable<TodoVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<TodoVm>><any>_observableThrow(response_);
        }));
    }

    protected processAddTodoToPc(response: HttpResponseBase): Observable<TodoVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? TodoVm.fromJS(resultData201) : new TodoVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TodoVm>(<any>null);
    }

    /**
     * AddStoryToPc
     */
    addStoryToPc(storyVm: StoryVm, pcId: string): Observable<TodoVm> {
        let url_ = this.baseUrl + "/histories/story/pc?";
        if (pcId === undefined || pcId === null)
            throw new Error("The parameter 'pcId' must be defined and cannot be null.");
        else
            url_ += "pcId=" + encodeURIComponent("" + pcId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(storyVm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddStoryToPc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddStoryToPc(<any>response_);
                } catch (e) {
                    return <Observable<TodoVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<TodoVm>><any>_observableThrow(response_);
        }));
    }

    protected processAddStoryToPc(response: HttpResponseBase): Observable<TodoVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? TodoVm.fromJS(resultData201) : new TodoVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TodoVm>(<any>null);
    }

    /**
     * TransferTodoToStory
     */
    transferTodoToStory(id: string): Observable<StoryVm> {
        let url_ = this.baseUrl + "/histories/transfer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransferTodoToStory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferTodoToStory(<any>response_);
                } catch (e) {
                    return <Observable<StoryVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoryVm>><any>_observableThrow(response_);
        }));
    }

    protected processTransferTodoToStory(response: HttpResponseBase): Observable<StoryVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? StoryVm.fromJS(resultData201) : new StoryVm();
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiException.fromJS(resultData400) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ApiException.fromJS(resultData500) : new ApiException();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoryVm>(<any>null);
    }
}

export class LoginParams implements ILoginParams {
    username!: string;
    password!: string;

    constructor(data?: ILoginParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginParams {
        data = typeof data === 'object' ? data : {};
        let result = new LoginParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface ILoginParams {
    username: string;
    password: string;
}

export class UserVm implements IUserVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    username!: string;
    role!: UserVmRole;

    constructor(data?: IUserVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] !== undefined ? data["createdAt"] : <any>null;
            this.updatedAt = data["updatedAt"] !== undefined ? data["updatedAt"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.role = data["role"] !== undefined ? data["role"] : <any>null;
        }
    }

    static fromJS(data: any): UserVm {
        data = typeof data === 'object' ? data : {};
        let result = new UserVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt !== undefined ? this.createdAt : <any>null;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        return data; 
    }
}

export interface IUserVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    username: string;
    role: UserVmRole;
}

export class LoginResponseVm implements ILoginResponseVm {
    accessToken!: string;
    user!: UserVm;

    constructor(data?: ILoginResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserVm();
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"] !== undefined ? data["accessToken"] : <any>null;
            this.user = data["user"] ? UserVm.fromJS(data["user"]) : new UserVm();
        }
    }

    static fromJS(data: any): LoginResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken !== undefined ? this.accessToken : <any>null;
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        return data; 
    }
}

export interface ILoginResponseVm {
    accessToken: string;
    user: UserVm;
}

export class ApiException implements IApiException {
    statusCode?: number | null;
    message?: string | null;
    status?: string | null;
    error?: string | null;
    errors?: any | null;
    timestamp?: string | null;
    path?: string | null;
    stack?: string | null;

    constructor(data?: IApiException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.statusCode = data["statusCode"] !== undefined ? data["statusCode"] : <any>null;
            this.message = data["message"] !== undefined ? data["message"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.error = data["error"] !== undefined ? data["error"] : <any>null;
            this.errors = data["errors"] !== undefined ? data["errors"] : <any>null;
            this.timestamp = data["timestamp"] !== undefined ? data["timestamp"] : <any>null;
            this.path = data["path"] !== undefined ? data["path"] : <any>null;
            this.stack = data["stack"] !== undefined ? data["stack"] : <any>null;
        }
    }

    static fromJS(data: any): ApiException {
        data = typeof data === 'object' ? data : {};
        let result = new ApiException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode !== undefined ? this.statusCode : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["errors"] = this.errors !== undefined ? this.errors : <any>null;
        data["timestamp"] = this.timestamp !== undefined ? this.timestamp : <any>null;
        data["path"] = this.path !== undefined ? this.path : <any>null;
        data["stack"] = this.stack !== undefined ? this.stack : <any>null;
        return data; 
    }
}

export interface IApiException {
    statusCode?: number | null;
    message?: string | null;
    status?: string | null;
    error?: string | null;
    errors?: any | null;
    timestamp?: string | null;
    path?: string | null;
    stack?: string | null;
}

export class CreateUserParams implements ICreateUserParams {
    username!: string;
    password!: string;
    role!: CreateUserParamsRole;

    constructor(data?: ICreateUserParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.role = data["role"] !== undefined ? data["role"] : <any>null;
        }
    }

    static fromJS(data: any): CreateUserParams {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        return data; 
    }
}

export interface ICreateUserParams {
    username: string;
    password: string;
    role: CreateUserParamsRole;
}

export class ChangePasswordParams implements IChangePasswordParams {
    current?: string | null;
    newPassword!: string;

    constructor(data?: IChangePasswordParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.current = data["current"] !== undefined ? data["current"] : <any>null;
            this.newPassword = data["newPassword"] !== undefined ? data["newPassword"] : <any>null;
        }
    }

    static fromJS(data: any): ChangePasswordParams {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["current"] = this.current !== undefined ? this.current : <any>null;
        data["newPassword"] = this.newPassword !== undefined ? this.newPassword : <any>null;
        return data; 
    }
}

export interface IChangePasswordParams {
    current?: string | null;
    newPassword: string;
}

export class FileReferenceVm implements IFileReferenceVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    publicUrl!: string;
    fileName!: string;
    itemId!: string;
    note?: string | null;

    constructor(data?: IFileReferenceVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] !== undefined ? data["createdAt"] : <any>null;
            this.updatedAt = data["updatedAt"] !== undefined ? data["updatedAt"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.publicUrl = data["publicUrl"] !== undefined ? data["publicUrl"] : <any>null;
            this.fileName = data["fileName"] !== undefined ? data["fileName"] : <any>null;
            this.itemId = data["itemId"] !== undefined ? data["itemId"] : <any>null;
            this.note = data["note"] !== undefined ? data["note"] : <any>null;
        }
    }

    static fromJS(data: any): FileReferenceVm {
        data = typeof data === 'object' ? data : {};
        let result = new FileReferenceVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt !== undefined ? this.createdAt : <any>null;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["publicUrl"] = this.publicUrl !== undefined ? this.publicUrl : <any>null;
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        data["itemId"] = this.itemId !== undefined ? this.itemId : <any>null;
        data["note"] = this.note !== undefined ? this.note : <any>null;
        return data; 
    }
}

export interface IFileReferenceVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    publicUrl: string;
    fileName: string;
    itemId: string;
    note?: string | null;
}

export class ItemVm implements IItemVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    donorId!: string;
    type!: ItemVmType;
    notes!: string;
    images?: FileReferenceVm[] | null;
    user?: string | null;
    status!: ItemVmStatus;
    barcodeId!: string;
    wikiLinks?: string[] | null;

    constructor(data?: IItemVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] !== undefined ? data["createdAt"] : <any>null;
            this.updatedAt = data["updatedAt"] !== undefined ? data["updatedAt"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.donorId = data["donorId"] !== undefined ? data["donorId"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.notes = data["notes"] !== undefined ? data["notes"] : <any>null;
            if (data["images"] && data["images"].constructor === Array) {
                this.images = [];
                for (let item of data["images"])
                    this.images.push(FileReferenceVm.fromJS(item));
            }
            this.user = data["user"] !== undefined ? data["user"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.barcodeId = data["barcodeId"] !== undefined ? data["barcodeId"] : <any>null;
            if (data["wikiLinks"] && data["wikiLinks"].constructor === Array) {
                this.wikiLinks = [];
                for (let item of data["wikiLinks"])
                    this.wikiLinks.push(item);
            }
        }
    }

    static fromJS(data: any): ItemVm {
        data = typeof data === 'object' ? data : {};
        let result = new ItemVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt !== undefined ? this.createdAt : <any>null;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["donorId"] = this.donorId !== undefined ? this.donorId : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        if (this.images && this.images.constructor === Array) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["user"] = this.user !== undefined ? this.user : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["barcodeId"] = this.barcodeId !== undefined ? this.barcodeId : <any>null;
        if (this.wikiLinks && this.wikiLinks.constructor === Array) {
            data["wikiLinks"] = [];
            for (let item of this.wikiLinks)
                data["wikiLinks"].push(item);
        }
        return data; 
    }
}

export interface IItemVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    donorId: string;
    type: ItemVmType;
    notes: string;
    images?: FileReferenceVm[] | null;
    user?: string | null;
    status: ItemVmStatus;
    barcodeId: string;
    wikiLinks?: string[] | null;
}

export class BikeAttribute implements IBikeAttribute {
    frameSize?: number | null;
    graduatedDate?: Date | null;
    serialNumber?: string | null;
    bikeType?: BikeAttributeBikeType | null;
    wheelSize?: number | null;
    marketPrice?: number | null;
    color?: string | null;
    stepOverHeight?: string | null;

    constructor(data?: IBikeAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.frameSize = data["frameSize"] !== undefined ? data["frameSize"] : <any>null;
            this.graduatedDate = data["graduatedDate"] ? new Date(data["graduatedDate"].toString()) : <any>null;
            this.serialNumber = data["serialNumber"] !== undefined ? data["serialNumber"] : <any>null;
            this.bikeType = data["bikeType"] !== undefined ? data["bikeType"] : <any>null;
            this.wheelSize = data["wheelSize"] !== undefined ? data["wheelSize"] : <any>null;
            this.marketPrice = data["marketPrice"] !== undefined ? data["marketPrice"] : <any>null;
            this.color = data["color"] !== undefined ? data["color"] : <any>null;
            this.stepOverHeight = data["stepOverHeight"] !== undefined ? data["stepOverHeight"] : <any>null;
        }
    }

    static fromJS(data: any): BikeAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new BikeAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frameSize"] = this.frameSize !== undefined ? this.frameSize : <any>null;
        data["graduatedDate"] = this.graduatedDate ? this.graduatedDate.toISOString() : <any>null;
        data["serialNumber"] = this.serialNumber !== undefined ? this.serialNumber : <any>null;
        data["bikeType"] = this.bikeType !== undefined ? this.bikeType : <any>null;
        data["wheelSize"] = this.wheelSize !== undefined ? this.wheelSize : <any>null;
        data["marketPrice"] = this.marketPrice !== undefined ? this.marketPrice : <any>null;
        data["color"] = this.color !== undefined ? this.color : <any>null;
        data["stepOverHeight"] = this.stepOverHeight !== undefined ? this.stepOverHeight : <any>null;
        return data; 
    }
}

export interface IBikeAttribute {
    frameSize?: number | null;
    graduatedDate?: Date | null;
    serialNumber?: string | null;
    bikeType?: BikeAttributeBikeType | null;
    wheelSize?: number | null;
    marketPrice?: number | null;
    color?: string | null;
    stepOverHeight?: string | null;
}

export class TodoVm implements ITodoVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    status!: TodoVmStatus;
    itemId?: string | null;
    person?: string | null;
    note?: string | null;
    type?: TodoVmType | null;
    isTransferred?: boolean | null;

    constructor(data?: ITodoVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] !== undefined ? data["createdAt"] : <any>null;
            this.updatedAt = data["updatedAt"] !== undefined ? data["updatedAt"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.itemId = data["itemId"] !== undefined ? data["itemId"] : <any>null;
            this.person = data["person"] !== undefined ? data["person"] : <any>null;
            this.note = data["note"] !== undefined ? data["note"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.isTransferred = data["isTransferred"] !== undefined ? data["isTransferred"] : <any>null;
        }
    }

    static fromJS(data: any): TodoVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodoVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt !== undefined ? this.createdAt : <any>null;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["itemId"] = this.itemId !== undefined ? this.itemId : <any>null;
        data["person"] = this.person !== undefined ? this.person : <any>null;
        data["note"] = this.note !== undefined ? this.note : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["isTransferred"] = this.isTransferred !== undefined ? this.isTransferred : <any>null;
        return data; 
    }
}

export interface ITodoVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    status: TodoVmStatus;
    itemId?: string | null;
    person?: string | null;
    note?: string | null;
    type?: TodoVmType | null;
    isTransferred?: boolean | null;
}

export class StoryVm implements IStoryVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    status!: StoryVmStatus;
    itemId?: string | null;
    person?: string | null;
    note?: string | null;
    type?: StoryVmType | null;
    transferredFromTodo?: boolean | null;

    constructor(data?: IStoryVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] !== undefined ? data["createdAt"] : <any>null;
            this.updatedAt = data["updatedAt"] !== undefined ? data["updatedAt"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.itemId = data["itemId"] !== undefined ? data["itemId"] : <any>null;
            this.person = data["person"] !== undefined ? data["person"] : <any>null;
            this.note = data["note"] !== undefined ? data["note"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.transferredFromTodo = data["transferredFromTodo"] !== undefined ? data["transferredFromTodo"] : <any>null;
        }
    }

    static fromJS(data: any): StoryVm {
        data = typeof data === 'object' ? data : {};
        let result = new StoryVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt !== undefined ? this.createdAt : <any>null;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["itemId"] = this.itemId !== undefined ? this.itemId : <any>null;
        data["person"] = this.person !== undefined ? this.person : <any>null;
        data["note"] = this.note !== undefined ? this.note : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["transferredFromTodo"] = this.transferredFromTodo !== undefined ? this.transferredFromTodo : <any>null;
        return data; 
    }
}

export interface IStoryVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    status: StoryVmStatus;
    itemId?: string | null;
    person?: string | null;
    note?: string | null;
    type?: StoryVmType | null;
    transferredFromTodo?: boolean | null;
}

export class BikeVm implements IBikeVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    donorId!: string;
    type!: BikeVmType;
    notes!: string;
    images?: FileReferenceVm[] | null;
    user?: string | null;
    status!: BikeVmStatus;
    barcodeId!: string;
    wikiLinks?: string[] | null;
    attributes?: BikeAttribute | null;
    todos?: TodoVm[] | null;
    stories?: StoryVm[] | null;

    constructor(data?: IBikeVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] !== undefined ? data["createdAt"] : <any>null;
            this.updatedAt = data["updatedAt"] !== undefined ? data["updatedAt"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.donorId = data["donorId"] !== undefined ? data["donorId"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.notes = data["notes"] !== undefined ? data["notes"] : <any>null;
            if (data["images"] && data["images"].constructor === Array) {
                this.images = [];
                for (let item of data["images"])
                    this.images.push(FileReferenceVm.fromJS(item));
            }
            this.user = data["user"] !== undefined ? data["user"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.barcodeId = data["barcodeId"] !== undefined ? data["barcodeId"] : <any>null;
            if (data["wikiLinks"] && data["wikiLinks"].constructor === Array) {
                this.wikiLinks = [];
                for (let item of data["wikiLinks"])
                    this.wikiLinks.push(item);
            }
            this.attributes = data["attributes"] ? BikeAttribute.fromJS(data["attributes"]) : <any>null;
            if (data["todos"] && data["todos"].constructor === Array) {
                this.todos = [];
                for (let item of data["todos"])
                    this.todos.push(TodoVm.fromJS(item));
            }
            if (data["stories"] && data["stories"].constructor === Array) {
                this.stories = [];
                for (let item of data["stories"])
                    this.stories.push(StoryVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BikeVm {
        data = typeof data === 'object' ? data : {};
        let result = new BikeVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt !== undefined ? this.createdAt : <any>null;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["donorId"] = this.donorId !== undefined ? this.donorId : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        if (this.images && this.images.constructor === Array) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["user"] = this.user !== undefined ? this.user : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["barcodeId"] = this.barcodeId !== undefined ? this.barcodeId : <any>null;
        if (this.wikiLinks && this.wikiLinks.constructor === Array) {
            data["wikiLinks"] = [];
            for (let item of this.wikiLinks)
                data["wikiLinks"].push(item);
        }
        data["attributes"] = this.attributes ? this.attributes.toJSON() : <any>null;
        if (this.todos && this.todos.constructor === Array) {
            data["todos"] = [];
            for (let item of this.todos)
                data["todos"].push(item.toJSON());
        }
        if (this.stories && this.stories.constructor === Array) {
            data["stories"] = [];
            for (let item of this.stories)
                data["stories"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBikeVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    donorId: string;
    type: BikeVmType;
    notes: string;
    images?: FileReferenceVm[] | null;
    user?: string | null;
    status: BikeVmStatus;
    barcodeId: string;
    wikiLinks?: string[] | null;
    attributes?: BikeAttribute | null;
    todos?: TodoVm[] | null;
    stories?: StoryVm[] | null;
}

export class NameAndDate implements INameAndDate {
    name?: string | null;
    date?: Date | null;

    constructor(data?: INameAndDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): NameAndDate {
        data = typeof data === 'object' ? data : {};
        let result = new NameAndDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        return data; 
    }
}

export interface INameAndDate {
    name?: string | null;
    date?: Date | null;
}

export class OSVersion implements IOSVersion {
    received?: string | null;
    bWorksUpdate?: string | null;

    constructor(data?: IOSVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.received = data["received"] !== undefined ? data["received"] : <any>null;
            this.bWorksUpdate = data["bWorksUpdate"] !== undefined ? data["bWorksUpdate"] : <any>null;
        }
    }

    static fromJS(data: any): OSVersion {
        data = typeof data === 'object' ? data : {};
        let result = new OSVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["received"] = this.received !== undefined ? this.received : <any>null;
        data["bWorksUpdate"] = this.bWorksUpdate !== undefined ? this.bWorksUpdate : <any>null;
        return data; 
    }
}

export interface IOSVersion {
    received?: string | null;
    bWorksUpdate?: string | null;
}

export class PCAttribute implements IPCAttribute {
    graduatedDate?: Date | null;
    processorCores?: number | null;
    processorSpeed?: number | null;
    processorType?: PCAttributeProcessorType | null;
    videoCard?: PCAttributeVideoCard | null;
    ram?: number | null;
    hardDrive?: number | null;
    cdDrive?: PCAttributeCdDrive | null;
    checkedInBy?: NameAndDate | null;
    installedBy?: NameAndDate | null;
    qualityAssuranceBy?: NameAndDate | null;
    osVersion?: OSVersion | null;

    constructor(data?: IPCAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.graduatedDate = data["graduatedDate"] ? new Date(data["graduatedDate"].toString()) : <any>null;
            this.processorCores = data["processorCores"] !== undefined ? data["processorCores"] : <any>null;
            this.processorSpeed = data["processorSpeed"] !== undefined ? data["processorSpeed"] : <any>null;
            this.processorType = data["processorType"] !== undefined ? data["processorType"] : <any>null;
            this.videoCard = data["videoCard"] !== undefined ? data["videoCard"] : <any>null;
            this.ram = data["ram"] !== undefined ? data["ram"] : <any>null;
            this.hardDrive = data["hardDrive"] !== undefined ? data["hardDrive"] : <any>null;
            this.cdDrive = data["cdDrive"] !== undefined ? data["cdDrive"] : <any>null;
            this.checkedInBy = data["checkedInBy"] ? NameAndDate.fromJS(data["checkedInBy"]) : <any>null;
            this.installedBy = data["installedBy"] ? NameAndDate.fromJS(data["installedBy"]) : <any>null;
            this.qualityAssuranceBy = data["qualityAssuranceBy"] ? NameAndDate.fromJS(data["qualityAssuranceBy"]) : <any>null;
            this.osVersion = data["osVersion"] ? OSVersion.fromJS(data["osVersion"]) : <any>null;
        }
    }

    static fromJS(data: any): PCAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new PCAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["graduatedDate"] = this.graduatedDate ? this.graduatedDate.toISOString() : <any>null;
        data["processorCores"] = this.processorCores !== undefined ? this.processorCores : <any>null;
        data["processorSpeed"] = this.processorSpeed !== undefined ? this.processorSpeed : <any>null;
        data["processorType"] = this.processorType !== undefined ? this.processorType : <any>null;
        data["videoCard"] = this.videoCard !== undefined ? this.videoCard : <any>null;
        data["ram"] = this.ram !== undefined ? this.ram : <any>null;
        data["hardDrive"] = this.hardDrive !== undefined ? this.hardDrive : <any>null;
        data["cdDrive"] = this.cdDrive !== undefined ? this.cdDrive : <any>null;
        data["checkedInBy"] = this.checkedInBy ? this.checkedInBy.toJSON() : <any>null;
        data["installedBy"] = this.installedBy ? this.installedBy.toJSON() : <any>null;
        data["qualityAssuranceBy"] = this.qualityAssuranceBy ? this.qualityAssuranceBy.toJSON() : <any>null;
        data["osVersion"] = this.osVersion ? this.osVersion.toJSON() : <any>null;
        return data; 
    }
}

export interface IPCAttribute {
    graduatedDate?: Date | null;
    processorCores?: number | null;
    processorSpeed?: number | null;
    processorType?: PCAttributeProcessorType | null;
    videoCard?: PCAttributeVideoCard | null;
    ram?: number | null;
    hardDrive?: number | null;
    cdDrive?: PCAttributeCdDrive | null;
    checkedInBy?: NameAndDate | null;
    installedBy?: NameAndDate | null;
    qualityAssuranceBy?: NameAndDate | null;
    osVersion?: OSVersion | null;
}

export class PCVm implements IPCVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    donorId!: string;
    type!: PCVmType;
    notes!: string;
    images?: FileReferenceVm[] | null;
    user?: string | null;
    status!: PCVmStatus;
    barcodeId!: string;
    wikiLinks?: string[] | null;
    attributes?: PCAttribute | null;
    todos?: TodoVm[] | null;
    stories?: StoryVm[] | null;

    constructor(data?: IPCVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] !== undefined ? data["createdAt"] : <any>null;
            this.updatedAt = data["updatedAt"] !== undefined ? data["updatedAt"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.donorId = data["donorId"] !== undefined ? data["donorId"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.notes = data["notes"] !== undefined ? data["notes"] : <any>null;
            if (data["images"] && data["images"].constructor === Array) {
                this.images = [];
                for (let item of data["images"])
                    this.images.push(FileReferenceVm.fromJS(item));
            }
            this.user = data["user"] !== undefined ? data["user"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.barcodeId = data["barcodeId"] !== undefined ? data["barcodeId"] : <any>null;
            if (data["wikiLinks"] && data["wikiLinks"].constructor === Array) {
                this.wikiLinks = [];
                for (let item of data["wikiLinks"])
                    this.wikiLinks.push(item);
            }
            this.attributes = data["attributes"] ? PCAttribute.fromJS(data["attributes"]) : <any>null;
            if (data["todos"] && data["todos"].constructor === Array) {
                this.todos = [];
                for (let item of data["todos"])
                    this.todos.push(TodoVm.fromJS(item));
            }
            if (data["stories"] && data["stories"].constructor === Array) {
                this.stories = [];
                for (let item of data["stories"])
                    this.stories.push(StoryVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PCVm {
        data = typeof data === 'object' ? data : {};
        let result = new PCVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt !== undefined ? this.createdAt : <any>null;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["donorId"] = this.donorId !== undefined ? this.donorId : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        if (this.images && this.images.constructor === Array) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["user"] = this.user !== undefined ? this.user : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["barcodeId"] = this.barcodeId !== undefined ? this.barcodeId : <any>null;
        if (this.wikiLinks && this.wikiLinks.constructor === Array) {
            data["wikiLinks"] = [];
            for (let item of this.wikiLinks)
                data["wikiLinks"].push(item);
        }
        data["attributes"] = this.attributes ? this.attributes.toJSON() : <any>null;
        if (this.todos && this.todos.constructor === Array) {
            data["todos"] = [];
            for (let item of this.todos)
                data["todos"].push(item.toJSON());
        }
        if (this.stories && this.stories.constructor === Array) {
            data["stories"] = [];
            for (let item of this.stories)
                data["stories"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPCVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    donorId: string;
    type: PCVmType;
    notes: string;
    images?: FileReferenceVm[] | null;
    user?: string | null;
    status: PCVmStatus;
    barcodeId: string;
    wikiLinks?: string[] | null;
    attributes?: PCAttribute | null;
    todos?: TodoVm[] | null;
    stories?: StoryVm[] | null;
}

export class PartVm implements IPartVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    donorId!: string;
    type!: PartVmType;
    notes!: string;
    images?: FileReferenceVm[] | null;
    user?: string | null;
    status!: PartVmStatus;
    barcodeId!: string;
    wikiLinks?: string[] | null;
    name?: string | null;
    description?: string | null;

    constructor(data?: IPartVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] !== undefined ? data["createdAt"] : <any>null;
            this.updatedAt = data["updatedAt"] !== undefined ? data["updatedAt"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.donorId = data["donorId"] !== undefined ? data["donorId"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.notes = data["notes"] !== undefined ? data["notes"] : <any>null;
            if (data["images"] && data["images"].constructor === Array) {
                this.images = [];
                for (let item of data["images"])
                    this.images.push(FileReferenceVm.fromJS(item));
            }
            this.user = data["user"] !== undefined ? data["user"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.barcodeId = data["barcodeId"] !== undefined ? data["barcodeId"] : <any>null;
            if (data["wikiLinks"] && data["wikiLinks"].constructor === Array) {
                this.wikiLinks = [];
                for (let item of data["wikiLinks"])
                    this.wikiLinks.push(item);
            }
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
        }
    }

    static fromJS(data: any): PartVm {
        data = typeof data === 'object' ? data : {};
        let result = new PartVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt !== undefined ? this.createdAt : <any>null;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["donorId"] = this.donorId !== undefined ? this.donorId : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        if (this.images && this.images.constructor === Array) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["user"] = this.user !== undefined ? this.user : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["barcodeId"] = this.barcodeId !== undefined ? this.barcodeId : <any>null;
        if (this.wikiLinks && this.wikiLinks.constructor === Array) {
            data["wikiLinks"] = [];
            for (let item of this.wikiLinks)
                data["wikiLinks"].push(item);
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data; 
    }
}

export interface IPartVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    donorId: string;
    type: PartVmType;
    notes: string;
    images?: FileReferenceVm[] | null;
    user?: string | null;
    status: PartVmStatus;
    barcodeId: string;
    wikiLinks?: string[] | null;
    name?: string | null;
    description?: string | null;
}

export class MiscVm implements IMiscVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    donorId!: string;
    type!: MiscVmType;
    notes!: string;
    images?: FileReferenceVm[] | null;
    user?: string | null;
    status!: MiscVmStatus;
    barcodeId!: string;
    wikiLinks?: string[] | null;
    name?: string | null;
    description?: string | null;

    constructor(data?: IMiscVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] !== undefined ? data["createdAt"] : <any>null;
            this.updatedAt = data["updatedAt"] !== undefined ? data["updatedAt"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.donorId = data["donorId"] !== undefined ? data["donorId"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.notes = data["notes"] !== undefined ? data["notes"] : <any>null;
            if (data["images"] && data["images"].constructor === Array) {
                this.images = [];
                for (let item of data["images"])
                    this.images.push(FileReferenceVm.fromJS(item));
            }
            this.user = data["user"] !== undefined ? data["user"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.barcodeId = data["barcodeId"] !== undefined ? data["barcodeId"] : <any>null;
            if (data["wikiLinks"] && data["wikiLinks"].constructor === Array) {
                this.wikiLinks = [];
                for (let item of data["wikiLinks"])
                    this.wikiLinks.push(item);
            }
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
        }
    }

    static fromJS(data: any): MiscVm {
        data = typeof data === 'object' ? data : {};
        let result = new MiscVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt !== undefined ? this.createdAt : <any>null;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["donorId"] = this.donorId !== undefined ? this.donorId : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        if (this.images && this.images.constructor === Array) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["user"] = this.user !== undefined ? this.user : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["barcodeId"] = this.barcodeId !== undefined ? this.barcodeId : <any>null;
        if (this.wikiLinks && this.wikiLinks.constructor === Array) {
            data["wikiLinks"] = [];
            for (let item of this.wikiLinks)
                data["wikiLinks"].push(item);
        }
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data; 
    }
}

export interface IMiscVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    donorId: string;
    type: MiscVmType;
    notes: string;
    images?: FileReferenceVm[] | null;
    user?: string | null;
    status: MiscVmStatus;
    barcodeId: string;
    wikiLinks?: string[] | null;
    name?: string | null;
    description?: string | null;
}

export class CreateDonorParams implements ICreateDonorParams {
    firstName!: string;
    lastName!: string;
    email!: string;
    zip?: number | null;
    phoneNumber?: string | null;
    refSource?: string | null;

    constructor(data?: ICreateDonorParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"] !== undefined ? data["firstName"] : <any>null;
            this.lastName = data["lastName"] !== undefined ? data["lastName"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.zip = data["zip"] !== undefined ? data["zip"] : <any>null;
            this.phoneNumber = data["phoneNumber"] !== undefined ? data["phoneNumber"] : <any>null;
            this.refSource = data["refSource"] !== undefined ? data["refSource"] : <any>null;
        }
    }

    static fromJS(data: any): CreateDonorParams {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDonorParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["zip"] = this.zip !== undefined ? this.zip : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["refSource"] = this.refSource !== undefined ? this.refSource : <any>null;
        return data; 
    }
}

export interface ICreateDonorParams {
    firstName: string;
    lastName: string;
    email: string;
    zip?: number | null;
    phoneNumber?: string | null;
    refSource?: string | null;
}

export class DonorVm implements IDonorVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    name!: string;
    email!: string;
    zip?: number | null;
    phoneNumber?: string | null;
    donations?: ItemVm[] | null;
    refSource?: string | null;

    constructor(data?: IDonorVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] !== undefined ? data["createdAt"] : <any>null;
            this.updatedAt = data["updatedAt"] !== undefined ? data["updatedAt"] : <any>null;
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.zip = data["zip"] !== undefined ? data["zip"] : <any>null;
            this.phoneNumber = data["phoneNumber"] !== undefined ? data["phoneNumber"] : <any>null;
            if (data["donations"] && data["donations"].constructor === Array) {
                this.donations = [];
                for (let item of data["donations"])
                    this.donations.push(ItemVm.fromJS(item));
            }
            this.refSource = data["refSource"] !== undefined ? data["refSource"] : <any>null;
        }
    }

    static fromJS(data: any): DonorVm {
        data = typeof data === 'object' ? data : {};
        let result = new DonorVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt !== undefined ? this.createdAt : <any>null;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["zip"] = this.zip !== undefined ? this.zip : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        if (this.donations && this.donations.constructor === Array) {
            data["donations"] = [];
            for (let item of this.donations)
                data["donations"].push(item.toJSON());
        }
        data["refSource"] = this.refSource !== undefined ? this.refSource : <any>null;
        return data; 
    }
}

export interface IDonorVm {
    createdAt?: string | null;
    updatedAt?: string | null;
    id?: string | null;
    name: string;
    email: string;
    zip?: number | null;
    phoneNumber?: string | null;
    donations?: ItemVm[] | null;
    refSource?: string | null;
}

export enum UserVmRole {
    Volunteer = "volunteer", 
    Staff = "staff", 
    Admin = "admin", 
}

export enum CreateUserParamsRole {
    Volunteer = "volunteer", 
    Staff = "staff", 
    Admin = "admin", 
}

export enum ItemVmType {
    Bike = "Bike", 
    PC = "PC", 
    Part = "Part", 
    Misc = "Misc", 
}

export enum ItemVmStatus {
    Received = "received", 
    Scraped = "scraped", 
    Donated = "donated", 
    Sold = "sold", 
    EarnBike = "earn-bike", 
    EarnPc = "earn-pc", 
    Progress = "progress", 
}

export enum BikeAttributeBikeType {
    Road = "road", 
    Cross = "cross", 
    Mtb = "mtb", 
    Hybrid = "hybrid", 
    Kid = "kid", 
}

export enum TodoVmStatus {
    Received = "received", 
    Scraped = "scraped", 
    Donated = "donated", 
    Sold = "sold", 
    EarnBike = "earn-bike", 
    EarnPc = "earn-pc", 
    Progress = "progress", 
}

export enum TodoVmType {
    Internal = "Internal", 
    External = "External", 
}

export enum StoryVmStatus {
    Received = "received", 
    Scraped = "scraped", 
    Donated = "donated", 
    Sold = "sold", 
    EarnBike = "earn-bike", 
    EarnPc = "earn-pc", 
    Progress = "progress", 
}

export enum StoryVmType {
    Internal = "Internal", 
    External = "External", 
}

export enum BikeVmType {
    Bike = "Bike", 
    PC = "PC", 
    Part = "Part", 
    Misc = "Misc", 
}

export enum BikeVmStatus {
    Received = "received", 
    Scraped = "scraped", 
    Donated = "donated", 
    Sold = "sold", 
    EarnBike = "earn-bike", 
    EarnPc = "earn-pc", 
    Progress = "progress", 
}

export enum PCAttributeProcessorType {
    Intel = "intel", 
    Amd = "amd", 
}

export enum PCAttributeVideoCard {
    Nvidia = "nvidia", 
    Amd = "amd", 
    Integrated = "integrated", 
}

export enum PCAttributeCdDrive {
    Rom = "rom", 
    R_w = "r/w", 
    None = "none", 
}

export enum PCVmType {
    Bike = "Bike", 
    PC = "PC", 
    Part = "Part", 
    Misc = "Misc", 
}

export enum PCVmStatus {
    Received = "received", 
    Scraped = "scraped", 
    Donated = "donated", 
    Sold = "sold", 
    EarnBike = "earn-bike", 
    EarnPc = "earn-pc", 
    Progress = "progress", 
}

export enum PartVmType {
    Bike = "Bike", 
    PC = "PC", 
    Part = "Part", 
    Misc = "Misc", 
}

export enum PartVmStatus {
    Received = "received", 
    Scraped = "scraped", 
    Donated = "donated", 
    Sold = "sold", 
    EarnBike = "earn-bike", 
    EarnPc = "earn-pc", 
    Progress = "progress", 
}

export enum MiscVmType {
    Bike = "Bike", 
    PC = "PC", 
    Part = "Part", 
    Misc = "Misc", 
}

export enum MiscVmStatus {
    Received = "received", 
    Scraped = "scraped", 
    Donated = "donated", 
    Sold = "sold", 
    EarnBike = "earn-bike", 
    EarnPc = "earn-pc", 
    Progress = "progress", 
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}